// Inline helpers to avoid import resolution issues with jiti
function normalizeRoute(path: string): string {
  return path.split("/").map(seg => {
    if (!seg) return seg;
    if (/^\d+$/.test(seg)) return ":id";
    if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(seg)) return ":id";
    if (/^[0-9a-f]{24,}$/i.test(seg)) return ":id";
    return seg;
  }).join("/");
}

function generateSkill(endpoints: any[], auth: any, domain: string) {
  const skillMd = [
    `# ${domain} API Skill`, "",
    "> Auto-generated by Unbrowse", "",
    "## Auth", "",
    `- Method: \`${auth?.method || "none"}\``,
    auth?.method === "bearer" ? "- Header: `Authorization: Bearer <token>`" : "",
    "", "## Endpoints", "",
    "| Method | Path | Description |",
    "|--------|------|-------------|",
    ...endpoints.map((ep: any) => `| ${ep.method} | \`${ep.path}\` | ${ep.description || ""} |`),
    "", "## Usage", "",
    "```typescript",
    'import { createClient } from "./api";',
    "",
    "const client = createClient();",
    "```",
  ].filter(l => l !== undefined).join("\n");

  const apiTs = [
    `/** Auto-generated API client for ${domain} â€” by Unbrowse */`,
    `const BASE_URL = "https://${domain}";`,
    `interface ApiConfig { token?: string; }`,
    `export function createClient(config: ApiConfig = {}) {`,
    `  const headers: Record<string, string> = { "Content-Type": "application/json" };`,
    `  if (config.token) headers["Authorization"] = \`Bearer \${config.token}\`;`,
    `  async function request(method: string, path: string, body?: unknown) {`,
    `    const res = await fetch(\`\${BASE_URL}\${path}\`, { method, headers, body: body ? JSON.stringify(body) : undefined });`,
    `    return res.json();`,
    `  }`,
    `  return {`,
    ...endpoints.map((ep: any) => {
      const hasParam = ep.path.includes(":id");
      const segments = ep.path.split("/").filter(Boolean).map((s: string) => s.replace(/[{}:]/g, ""));
      const fnName = ep.method.toLowerCase() + segments.map((s: string) => s.charAt(0).toUpperCase() + s.slice(1)).join("");
      if (hasParam) return `    /** ${ep.description || ""} */\n    ${fnName}: (id: string) => request("${ep.method}", \`${ep.path.replace(/:id/g, "${id}")}\`),`;
      return `    /** ${ep.description || ""} */\n    ${fnName}: () => request("${ep.method}", "${ep.path}"),`;
    }),
    `  };`,
    `}`,
  ].join("\n");

  return { skillMd, apiTs };
}

export default function register(api: any) {

  // Tool 1: unbrowse_capture
  api.registerTool({
    name: "unbrowse_capture",
    description: "Visit a URL and capture the internal API calls the website makes. Returns discovered endpoints that can be used to generate skills. Much faster than browser automation.",
    parameters: {
      type: "object",
      properties: {
        url: { type: "string", description: "URL to visit and capture API traffic from" },
        waitMs: { type: "number", description: "Extra milliseconds to wait for API calls (default: 2000)" }
      },
      required: ["url"]
    },
    async execute(_id: string, params: any) {
      const start = Date.now();
      try {
        const res = await fetch(params.url, { redirect: "follow" });
        const headers: Record<string, string> = {};
        res.headers.forEach((v: string, k: string) => { headers[k] = v; });
        const contentType = headers["content-type"] || "";
        const isJson = contentType.includes("json");
        const body = isJson ? await res.json() : await res.text();
        const ms = Date.now() - start;
        const domain = new URL(params.url).hostname;
        return {
          content: [{
            type: "text",
            text: JSON.stringify({
              success: true, url: params.url, domain, status: res.status,
              contentType, isApi: isJson, latencyMs: ms,
              headers: Object.fromEntries(Object.entries(headers).slice(0, 10)),
              responsePreview: isJson ? JSON.stringify(body).slice(0, 500) : (body as string).slice(0, 500),
              hint: isJson ? "This looks like an API endpoint! Use unbrowse_learn to generate a skill." : "HTML page. Browse to discover internal API calls, or use unbrowse_learn with a HAR file."
            }, null, 2)
          }]
        };
      } catch (e: any) {
        return { content: [{ type: "text", text: JSON.stringify({ success: false, error: e.message }) }] };
      }
    }
  });

  // Tool 2: unbrowse_learn
  api.registerTool({
    name: "unbrowse_learn",
    description: "Parse captured API traffic (HAR format or endpoint list) and generate a typed SKILL.md + api.ts client. This creates a reusable API skill from observed HTTP requests.",
    parameters: {
      type: "object",
      properties: {
        domain: { type: "string", description: "The domain to generate a skill for (e.g. api.example.com)" },
        endpoints: {
          type: "array", description: "List of observed endpoints",
          items: { type: "object", properties: { method: { type: "string" }, path: { type: "string" }, description: { type: "string" } }, required: ["method", "path"] }
        },
        harContent: { type: "string", description: "Raw HAR JSON content (alternative to endpoints)" },
        authMethod: { type: "string", description: "Auth method: bearer, apikey, session, none" }
      },
      required: ["domain"]
    },
    async execute(_id: string, params: any) {
      let endpoints = params.endpoints || [];
      const auth = { method: params.authMethod || "none" };

      if (params.harContent) {
        try {
          const har = JSON.parse(params.harContent);
          const entries = har?.log?.entries || [];
          endpoints = entries
            .filter((e: any) => e.response?.content?.mimeType?.includes("json"))
            .map((e: any) => {
              const url = new URL(e.request.url);
              return { method: e.request.method, path: normalizeRoute(url.pathname), description: `${e.request.method} ${url.pathname}` };
            });
        } catch (e: any) {
          return { content: [{ type: "text", text: JSON.stringify({ error: `Failed to parse HAR: ${e.message}` }) }] };
        }
      }

      const normalized = endpoints.map((ep: any) => ({ ...ep, path: normalizeRoute(ep.path) }));
      const { skillMd, apiTs } = generateSkill(normalized, auth, params.domain);

      // Save to skills directory
      const fs = require("fs");
      const path = require("path");
      const skillsDir = path.resolve(process.cwd(), "skills", params.domain);
      fs.mkdirSync(skillsDir, { recursive: true });
      fs.writeFileSync(path.join(skillsDir, "SKILL.md"), skillMd);
      fs.writeFileSync(path.join(skillsDir, "api.ts"), apiTs);

      return {
        content: [{
          type: "text",
          text: `Generated skill for ${params.domain}:\n\nðŸ“ Saved to: skills/${params.domain}/\nðŸ“ Endpoints: ${normalized.length}\nðŸ” Auth: ${auth.method}\n\n--- SKILL.md ---\n${skillMd}\n\n--- api.ts ---\n${apiTs}`
        }]
      };
    }
  });

  // Tool 3: unbrowse_replay
  api.registerTool({
    name: "unbrowse_replay",
    description: "Execute a web API call directly without browser automation. 100x faster than Puppeteer/Playwright. Provide the endpoint details and get the response instantly.",
    parameters: {
      type: "object",
      properties: {
        url: { type: "string", description: "Full URL to call" },
        method: { type: "string", description: "HTTP method (GET, POST, PUT, DELETE)", default: "GET" },
        headers: { type: "object", description: "Request headers" },
        body: { type: "string", description: "Request body (for POST/PUT)" }
      },
      required: ["url"]
    },
    async execute(_id: string, params: any) {
      const start = Date.now();
      try {
        const res = await fetch(params.url, {
          method: params.method || "GET",
          headers: { Accept: "application/json", ...(params.headers || {}) },
          body: params.body || undefined
        });
        const ms = Date.now() - start;
        const ct = res.headers.get("content-type") || "";
        const data = ct.includes("json") ? await res.json() : await res.text();
        return { content: [{ type: "text", text: JSON.stringify({ success: res.status >= 200 && res.status < 400, status: res.status, latencyMs: ms, contentType: ct, data: typeof data === "string" ? data.slice(0, 2000) : data }, null, 2) }] };
      } catch (e: any) {
        return { content: [{ type: "text", text: JSON.stringify({ success: false, error: e.message, latencyMs: Date.now() - start }) }] };
      }
    }
  });

  // Tool 4: unbrowse_search
  api.registerTool({
    name: "unbrowse_search",
    description: "Search the Unbrowse skill marketplace for pre-built API skills. Find skills by domain, keyword, or tag.",
    parameters: {
      type: "object",
      properties: {
        query: { type: "string", description: "Search query (domain name, keyword, or tag)" },
        serverUrl: { type: "string", description: "Marketplace server URL (default: http://localhost:4111)" }
      },
      required: ["query"]
    },
    async execute(_id: string, params: any) {
      const server = params.serverUrl || "http://localhost:4111";
      try {
        const res = await fetch(`${server}/api/marketplace/search?q=${encodeURIComponent(params.query)}`);
        const data = await res.json();
        return { content: [{ type: "text", text: JSON.stringify(data, null, 2) }] };
      } catch (e: any) {
        return { content: [{ type: "text", text: JSON.stringify({ error: e.message, hint: "Make sure the Unbrowse server is running" }) }] };
      }
    }
  });

  // Tool 5: unbrowse_skills
  api.registerTool({
    name: "unbrowse_skills",
    description: "List all locally generated API skills. Shows domains, endpoint counts, and auth methods.",
    parameters: { type: "object", properties: {} },
    async execute() {
      const fs = require("fs");
      const path = require("path");
      const skillsDir = path.resolve(process.cwd(), "skills");
      if (!fs.existsSync(skillsDir)) return { content: [{ type: "text", text: "No skills directory found." }] };
      const domains = fs.readdirSync(skillsDir).filter((d: string) => {
        const p = path.join(skillsDir, d);
        return fs.statSync(p).isDirectory() && fs.existsSync(path.join(p, "SKILL.md"));
      });
      const skills = domains.map((domain: string) => {
        const md = fs.readFileSync(path.join(skillsDir, domain, "SKILL.md"), "utf-8");
        const count = (md.match(/^\|?\s*(GET|POST|PUT|PATCH|DELETE)/gm) || []).length;
        return { domain, endpoints: count, hasApiClient: fs.existsSync(path.join(skillsDir, domain, "api.ts")) };
      });
      return { content: [{ type: "text", text: JSON.stringify({ skills, total: skills.length }, null, 2) }] };
    }
  });
}
