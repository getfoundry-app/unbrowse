import type { ParsedRequest, AuthInfo, NormalizedEndpoint } from './types.js';
import { normalizeRoute } from './route-normalizer.js';
import { fingerprint } from './endpoint-fingerprinter.js';

export class SkillGenerator {
  generate(
    parsedRequests: ParsedRequest[],
    auth: AuthInfo,
    domain: string,
  ): { skillMd: string; apiTs: string } {
    const endpoints = this.deduplicateEndpoints(parsedRequests);
    const skillMd = this.buildSkillMd(endpoints, auth, domain);
    const apiTs = this.buildApiTs(endpoints, auth, domain);
    return { skillMd, apiTs };
  }

  private deduplicateEndpoints(requests: ParsedRequest[]): NormalizedEndpoint[] {
    const seen = new Set<string>();
    const endpoints: NormalizedEndpoint[] = [];

    for (const req of requests) {
      const normalized = normalizeRoute(req.path);
      const fp = fingerprint(req.method, normalized);
      if (seen.has(fp)) continue;
      seen.add(fp);

      endpoints.push({
        method: req.method,
        path: normalized,
        originalPath: req.path,
        fingerprint: fp,
      });
    }

    return endpoints;
  }

  private buildSkillMd(
    endpoints: NormalizedEndpoint[],
    auth: AuthInfo,
    domain: string,
  ): string {
    const lines: string[] = [
      `# ${domain} API Skill`,
      '',
      `> Auto-generated by Unbrowse from captured traffic.`,
      '',
      `## Authentication`,
      '',
      `Method: \`${auth.method}\``,
      '',
      '## Endpoints',
      '',
    ];

    for (const ep of endpoints) {
      lines.push(`### \`${ep.method} ${ep.path}\``);
      lines.push('');
      lines.push(`- Original path: \`${ep.originalPath}\``);
      lines.push(`- Fingerprint: \`${ep.fingerprint.slice(0, 12)}\``);
      lines.push('');
    }

    return lines.join('\n');
  }

  private buildApiTs(
    endpoints: NormalizedEndpoint[],
    auth: AuthInfo,
    domain: string,
  ): string {
    const lines: string[] = [
      `// Auto-generated API client for ${domain}`,
      `// Generated by Unbrowse`,
      '',
      `const BASE_URL = "https://${domain}";`,
      '',
      `interface RequestOptions {`,
      `  headers?: Record<string, string>;`,
      `}`,
      '',
      this.buildAuthHelper(auth),
      '',
    ];

    for (const ep of endpoints) {
      const fnName = this.endpointToFnName(ep);
      const hasId = ep.path.includes('{id}');
      const params = hasId ? 'id: string, options?: RequestOptions' : 'options?: RequestOptions';
      const urlExpr = hasId
        ? `\`\${BASE_URL}${ep.path.replace(/\{id\}/g, '${id}')}\``
        : `\`\${BASE_URL}${ep.path}\``;

      lines.push(`export async function ${fnName}(${params}): Promise<unknown> {`);
      lines.push(`  const res = await fetch(${urlExpr}, {`);
      lines.push(`    method: "${ep.method}",`);
      lines.push(`    headers: { ...getAuthHeaders(), ...options?.headers },`);
      lines.push(`  });`);
      lines.push(`  return res.json();`);
      lines.push(`}`);
      lines.push('');
    }

    return lines.join('\n');
  }

  private buildAuthHelper(auth: AuthInfo): string {
    switch (auth.method) {
      case 'bearer':
        return [
          `function getAuthHeaders(): Record<string, string> {`,
          `  const token = process.env.API_TOKEN ?? "";`,
          `  return { Authorization: \`Bearer \${token}\` };`,
          `}`,
        ].join('\n');
      case 'apikey': {
        const keyName = Object.keys(auth.headers).find(
          h => h.toLowerCase().includes('api-key') || h.toLowerCase().includes('apikey'),
        ) ?? 'X-Api-Key';
        return [
          `function getAuthHeaders(): Record<string, string> {`,
          `  const key = process.env.API_KEY ?? "";`,
          `  return { "${keyName}": key };`,
          `}`,
        ].join('\n');
      }
      default:
        return [
          `function getAuthHeaders(): Record<string, string> {`,
          `  return {};`,
          `}`,
        ].join('\n');
    }
  }

  private endpointToFnName(ep: NormalizedEndpoint): string {
    const verb = ep.method.toLowerCase();
    const parts = ep.path
      .split('/')
      .filter(s => s && s !== '{id}')
      .map(s => s.charAt(0).toUpperCase() + s.slice(1));
    return `${verb}${parts.join('')}`;
  }
}
